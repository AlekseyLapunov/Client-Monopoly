// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MonopolyGameMessages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MonopolyGameMessages_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_MonopolyGameMessages_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_MonopolyGameMessages_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MonopolyGameMessages_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_MonopolyGameMessages_2eproto;
namespace MonopolyGameMessages {
class AwaitedResolve;
struct AwaitedResolveDefaultTypeInternal;
extern AwaitedResolveDefaultTypeInternal _AwaitedResolve_default_instance_;
class BuyArrowResolve;
struct BuyArrowResolveDefaultTypeInternal;
extern BuyArrowResolveDefaultTypeInternal _BuyArrowResolve_default_instance_;
class BuyResolve;
struct BuyResolveDefaultTypeInternal;
extern BuyResolveDefaultTypeInternal _BuyResolve_default_instance_;
class ClientHello;
struct ClientHelloDefaultTypeInternal;
extern ClientHelloDefaultTypeInternal _ClientHello_default_instance_;
class Dices;
struct DicesDefaultTypeInternal;
extern DicesDefaultTypeInternal _Dices_default_instance_;
class DicesAreDrawn;
struct DicesAreDrawnDefaultTypeInternal;
extern DicesAreDrawnDefaultTypeInternal _DicesAreDrawn_default_instance_;
class DoSabotageResolve;
struct DoSabotageResolveDefaultTypeInternal;
extern DoSabotageResolveDefaultTypeInternal _DoSabotageResolve_default_instance_;
class GameState;
struct GameStateDefaultTypeInternal;
extern GameStateDefaultTypeInternal _GameState_default_instance_;
class PieceMovingIsDrawn;
struct PieceMovingIsDrawnDefaultTypeInternal;
extern PieceMovingIsDrawnDefaultTypeInternal _PieceMovingIsDrawn_default_instance_;
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class ServerHello;
struct ServerHelloDefaultTypeInternal;
extern ServerHelloDefaultTypeInternal _ServerHello_default_instance_;
class StateRefresh;
struct StateRefreshDefaultTypeInternal;
extern StateRefreshDefaultTypeInternal _StateRefresh_default_instance_;
class Tile;
struct TileDefaultTypeInternal;
extern TileDefaultTypeInternal _Tile_default_instance_;
class TileStat;
struct TileStatDefaultTypeInternal;
extern TileStatDefaultTypeInternal _TileStat_default_instance_;
class TimeForResolveOut;
struct TimeForResolveOutDefaultTypeInternal;
extern TimeForResolveOutDefaultTypeInternal _TimeForResolveOut_default_instance_;
class TimeForWaitOut;
struct TimeForWaitOutDefaultTypeInternal;
extern TimeForWaitOutDefaultTypeInternal _TimeForWaitOut_default_instance_;
}  // namespace MonopolyGameMessages
PROTOBUF_NAMESPACE_OPEN
template <>
::MonopolyGameMessages::AwaitedResolve* Arena::CreateMaybeMessage<::MonopolyGameMessages::AwaitedResolve>(Arena*);
template <>
::MonopolyGameMessages::BuyArrowResolve* Arena::CreateMaybeMessage<::MonopolyGameMessages::BuyArrowResolve>(Arena*);
template <>
::MonopolyGameMessages::BuyResolve* Arena::CreateMaybeMessage<::MonopolyGameMessages::BuyResolve>(Arena*);
template <>
::MonopolyGameMessages::ClientHello* Arena::CreateMaybeMessage<::MonopolyGameMessages::ClientHello>(Arena*);
template <>
::MonopolyGameMessages::Dices* Arena::CreateMaybeMessage<::MonopolyGameMessages::Dices>(Arena*);
template <>
::MonopolyGameMessages::DicesAreDrawn* Arena::CreateMaybeMessage<::MonopolyGameMessages::DicesAreDrawn>(Arena*);
template <>
::MonopolyGameMessages::DoSabotageResolve* Arena::CreateMaybeMessage<::MonopolyGameMessages::DoSabotageResolve>(Arena*);
template <>
::MonopolyGameMessages::GameState* Arena::CreateMaybeMessage<::MonopolyGameMessages::GameState>(Arena*);
template <>
::MonopolyGameMessages::PieceMovingIsDrawn* Arena::CreateMaybeMessage<::MonopolyGameMessages::PieceMovingIsDrawn>(Arena*);
template <>
::MonopolyGameMessages::Player* Arena::CreateMaybeMessage<::MonopolyGameMessages::Player>(Arena*);
template <>
::MonopolyGameMessages::ServerHello* Arena::CreateMaybeMessage<::MonopolyGameMessages::ServerHello>(Arena*);
template <>
::MonopolyGameMessages::StateRefresh* Arena::CreateMaybeMessage<::MonopolyGameMessages::StateRefresh>(Arena*);
template <>
::MonopolyGameMessages::Tile* Arena::CreateMaybeMessage<::MonopolyGameMessages::Tile>(Arena*);
template <>
::MonopolyGameMessages::TileStat* Arena::CreateMaybeMessage<::MonopolyGameMessages::TileStat>(Arena*);
template <>
::MonopolyGameMessages::TimeForResolveOut* Arena::CreateMaybeMessage<::MonopolyGameMessages::TimeForResolveOut>(Arena*);
template <>
::MonopolyGameMessages::TimeForWaitOut* Arena::CreateMaybeMessage<::MonopolyGameMessages::TimeForWaitOut>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace MonopolyGameMessages {
enum AwaitedMessage : int {
  DICES_ARE_DRAWN = 0,
  PIECE_MOVING_IS_DRAWN = 1,
  TIME_FOR_RESOLVE_OUT = 2,
  BUY_RESOLVE = 3,
  DO_SABOTAGE_RESOLVE = 4,
  BUY_ARROW_RESOLVE = 5,
  TIME_FOR_WAIT_OUT = 6,
  AwaitedMessage_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AwaitedMessage_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AwaitedMessage_IsValid(int value);
constexpr AwaitedMessage AwaitedMessage_MIN = static_cast<AwaitedMessage>(0);
constexpr AwaitedMessage AwaitedMessage_MAX = static_cast<AwaitedMessage>(6);
constexpr int AwaitedMessage_ARRAYSIZE = 6 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
AwaitedMessage_descriptor();
template <typename T>
const std::string& AwaitedMessage_Name(T value) {
  static_assert(std::is_same<T, AwaitedMessage>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AwaitedMessage_Name().");
  return AwaitedMessage_Name(static_cast<AwaitedMessage>(value));
}
template <>
inline const std::string& AwaitedMessage_Name(AwaitedMessage value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<AwaitedMessage_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool AwaitedMessage_Parse(absl::string_view name, AwaitedMessage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AwaitedMessage>(
      AwaitedMessage_descriptor(), name, value);
}
enum TileType : int {
  VOID = 0,
  COMMON = 1,
  BEGINNING = 2,
  SAWMILL = 3,
  COAL_STATION = 4,
  ATOMIC_STATION = 5,
  FOREST = 6,
  COAL = 7,
  URANIUM = 8,
  VACATION = 9,
  SABOTAGE = 10,
  ARROW = 11,
  TileType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TileType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TileType_IsValid(int value);
constexpr TileType TileType_MIN = static_cast<TileType>(0);
constexpr TileType TileType_MAX = static_cast<TileType>(11);
constexpr int TileType_ARRAYSIZE = 11 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
TileType_descriptor();
template <typename T>
const std::string& TileType_Name(T value) {
  static_assert(std::is_same<T, TileType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TileType_Name().");
  return TileType_Name(static_cast<TileType>(value));
}
template <>
inline const std::string& TileType_Name(TileType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<TileType_descriptor,
                                                 0, 11>(
      static_cast<int>(value));
}
inline bool TileType_Parse(absl::string_view name, TileType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TileType>(
      TileType_descriptor(), name, value);
}
enum ArrowDirection : int {
  UP = 0,
  RIGHT = 1,
  DOWN = 2,
  LEFT = 3,
  ArrowDirection_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ArrowDirection_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ArrowDirection_IsValid(int value);
constexpr ArrowDirection ArrowDirection_MIN = static_cast<ArrowDirection>(0);
constexpr ArrowDirection ArrowDirection_MAX = static_cast<ArrowDirection>(3);
constexpr int ArrowDirection_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ArrowDirection_descriptor();
template <typename T>
const std::string& ArrowDirection_Name(T value) {
  static_assert(std::is_same<T, ArrowDirection>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ArrowDirection_Name().");
  return ArrowDirection_Name(static_cast<ArrowDirection>(value));
}
template <>
inline const std::string& ArrowDirection_Name(ArrowDirection value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ArrowDirection_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ArrowDirection_Parse(absl::string_view name, ArrowDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArrowDirection>(
      ArrowDirection_descriptor(), name, value);
}
enum PlayerNumber : int {
  NONE = 0,
  PLAYER1 = 1,
  PLAYER2 = 2,
  PLAYER3 = 3,
  PLAYER4 = 4,
  PLAYER5 = 5,
  PLAYER6 = 6,
  PlayerNumber_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PlayerNumber_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PlayerNumber_IsValid(int value);
constexpr PlayerNumber PlayerNumber_MIN = static_cast<PlayerNumber>(0);
constexpr PlayerNumber PlayerNumber_MAX = static_cast<PlayerNumber>(6);
constexpr int PlayerNumber_ARRAYSIZE = 6 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
PlayerNumber_descriptor();
template <typename T>
const std::string& PlayerNumber_Name(T value) {
  static_assert(std::is_same<T, PlayerNumber>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PlayerNumber_Name().");
  return PlayerNumber_Name(static_cast<PlayerNumber>(value));
}
template <>
inline const std::string& PlayerNumber_Name(PlayerNumber value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<PlayerNumber_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool PlayerNumber_Parse(absl::string_view name, PlayerNumber* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerNumber>(
      PlayerNumber_descriptor(), name, value);
}
enum State : int {
  WAITING = 0,
  RELAX = 1,
  PLAYER_TURN = 2,
  END = 3,
  State_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  State_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool State_IsValid(int value);
constexpr State State_MIN = static_cast<State>(0);
constexpr State State_MAX = static_cast<State>(3);
constexpr int State_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
State_descriptor();
template <typename T>
const std::string& State_Name(T value) {
  static_assert(std::is_same<T, State>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to State_Name().");
  return State_Name(static_cast<State>(value));
}
template <>
inline const std::string& State_Name(State value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<State_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool State_Parse(absl::string_view name, State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<State>(
      State_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class ClientHello final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.ClientHello) */ {
 public:
  inline ClientHello() : ClientHello(nullptr) {}
  ~ClientHello() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClientHello(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientHello(const ClientHello& from);
  ClientHello(ClientHello&& from) noexcept
    : ClientHello() {
    *this = ::std::move(from);
  }

  inline ClientHello& operator=(const ClientHello& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientHello& operator=(ClientHello&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientHello& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientHello* internal_default_instance() {
    return reinterpret_cast<const ClientHello*>(
               &_ClientHello_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ClientHello& a, ClientHello& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientHello* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientHello* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientHello* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientHello>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientHello& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientHello& from) {
    ClientHello::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientHello* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.ClientHello";
  }
  protected:
  explicit ClientHello(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.ClientHello)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};// -------------------------------------------------------------------

class ServerHello final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.ServerHello) */ {
 public:
  inline ServerHello() : ServerHello(nullptr) {}
  ~ServerHello() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ServerHello(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerHello(const ServerHello& from);
  ServerHello(ServerHello&& from) noexcept
    : ServerHello() {
    *this = ::std::move(from);
  }

  inline ServerHello& operator=(const ServerHello& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerHello& operator=(ServerHello&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerHello& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerHello* internal_default_instance() {
    return reinterpret_cast<const ServerHello*>(
               &_ServerHello_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ServerHello& a, ServerHello& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerHello* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerHello* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerHello* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerHello>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerHello& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerHello& from) {
    ServerHello::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerHello* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.ServerHello";
  }
  protected:
  explicit ServerHello(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 4,
    kBaseCostFieldNumber = 5,
    kBaseIncomeFieldNumber = 6,
    kLobbyNameFieldNumber = 2,
    kCurrentGameStateFieldNumber = 7,
    kLobbyIDFieldNumber = 1,
    kTimeForResolveFieldNumber = 3,
  };
  // repeated .MonopolyGameMessages.Player players = 4;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::MonopolyGameMessages::Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::Player >*
      mutable_players();
  private:
  const ::MonopolyGameMessages::Player& _internal_players(int index) const;
  ::MonopolyGameMessages::Player* _internal_add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::Player>& _internal_players() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::Player>* _internal_mutable_players();
  public:
  const ::MonopolyGameMessages::Player& players(int index) const;
  ::MonopolyGameMessages::Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::Player >&
      players() const;
  // repeated .MonopolyGameMessages.TileStat baseCost = 5;
  int basecost_size() const;
  private:
  int _internal_basecost_size() const;

  public:
  void clear_basecost() ;
  ::MonopolyGameMessages::TileStat* mutable_basecost(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::TileStat >*
      mutable_basecost();
  private:
  const ::MonopolyGameMessages::TileStat& _internal_basecost(int index) const;
  ::MonopolyGameMessages::TileStat* _internal_add_basecost();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::TileStat>& _internal_basecost() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::TileStat>* _internal_mutable_basecost();
  public:
  const ::MonopolyGameMessages::TileStat& basecost(int index) const;
  ::MonopolyGameMessages::TileStat* add_basecost();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::TileStat >&
      basecost() const;
  // repeated .MonopolyGameMessages.TileStat baseIncome = 6;
  int baseincome_size() const;
  private:
  int _internal_baseincome_size() const;

  public:
  void clear_baseincome() ;
  ::MonopolyGameMessages::TileStat* mutable_baseincome(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::TileStat >*
      mutable_baseincome();
  private:
  const ::MonopolyGameMessages::TileStat& _internal_baseincome(int index) const;
  ::MonopolyGameMessages::TileStat* _internal_add_baseincome();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::TileStat>& _internal_baseincome() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::TileStat>* _internal_mutable_baseincome();
  public:
  const ::MonopolyGameMessages::TileStat& baseincome(int index) const;
  ::MonopolyGameMessages::TileStat* add_baseincome();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::TileStat >&
      baseincome() const;
  // string lobbyName = 2;
  void clear_lobbyname() ;
  const std::string& lobbyname() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lobbyname(Arg_&& arg, Args_... args);
  std::string* mutable_lobbyname();
  PROTOBUF_NODISCARD std::string* release_lobbyname();
  void set_allocated_lobbyname(std::string* ptr);

  private:
  const std::string& _internal_lobbyname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lobbyname(
      const std::string& value);
  std::string* _internal_mutable_lobbyname();

  public:
  // .MonopolyGameMessages.GameState currentGameState = 7;
  bool has_currentgamestate() const;
  void clear_currentgamestate() ;
  const ::MonopolyGameMessages::GameState& currentgamestate() const;
  PROTOBUF_NODISCARD ::MonopolyGameMessages::GameState* release_currentgamestate();
  ::MonopolyGameMessages::GameState* mutable_currentgamestate();
  void set_allocated_currentgamestate(::MonopolyGameMessages::GameState* currentgamestate);
  private:
  const ::MonopolyGameMessages::GameState& _internal_currentgamestate() const;
  ::MonopolyGameMessages::GameState* _internal_mutable_currentgamestate();
  public:
  void unsafe_arena_set_allocated_currentgamestate(
      ::MonopolyGameMessages::GameState* currentgamestate);
  ::MonopolyGameMessages::GameState* unsafe_arena_release_currentgamestate();
  // uint32 lobbyID = 1;
  void clear_lobbyid() ;
  ::uint32_t lobbyid() const;
  void set_lobbyid(::uint32_t value);

  private:
  ::uint32_t _internal_lobbyid() const;
  void _internal_set_lobbyid(::uint32_t value);

  public:
  // uint32 timeForResolve = 3;
  void clear_timeforresolve() ;
  ::uint32_t timeforresolve() const;
  void set_timeforresolve(::uint32_t value);

  private:
  ::uint32_t _internal_timeforresolve() const;
  void _internal_set_timeforresolve(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.ServerHello)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::Player > players_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::TileStat > basecost_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::TileStat > baseincome_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lobbyname_;
    ::MonopolyGameMessages::GameState* currentgamestate_;
    ::uint32_t lobbyid_;
    ::uint32_t timeforresolve_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};// -------------------------------------------------------------------

class StateRefresh final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.StateRefresh) */ {
 public:
  inline StateRefresh() : StateRefresh(nullptr) {}
  ~StateRefresh() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StateRefresh(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateRefresh(const StateRefresh& from);
  StateRefresh(StateRefresh&& from) noexcept
    : StateRefresh() {
    *this = ::std::move(from);
  }

  inline StateRefresh& operator=(const StateRefresh& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateRefresh& operator=(StateRefresh&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateRefresh& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateRefresh* internal_default_instance() {
    return reinterpret_cast<const StateRefresh*>(
               &_StateRefresh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StateRefresh& a, StateRefresh& b) {
    a.Swap(&b);
  }
  inline void Swap(StateRefresh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateRefresh* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateRefresh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateRefresh>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StateRefresh& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StateRefresh& from) {
    StateRefresh::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateRefresh* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.StateRefresh";
  }
  protected:
  explicit StateRefresh(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentGameStateFieldNumber = 1,
    kAwaitedResolveFieldNumber = 2,
    kAwaitedSignalFieldNumber = 3,
  };
  // .MonopolyGameMessages.GameState currentGameState = 1;
  bool has_currentgamestate() const;
  void clear_currentgamestate() ;
  const ::MonopolyGameMessages::GameState& currentgamestate() const;
  PROTOBUF_NODISCARD ::MonopolyGameMessages::GameState* release_currentgamestate();
  ::MonopolyGameMessages::GameState* mutable_currentgamestate();
  void set_allocated_currentgamestate(::MonopolyGameMessages::GameState* currentgamestate);
  private:
  const ::MonopolyGameMessages::GameState& _internal_currentgamestate() const;
  ::MonopolyGameMessages::GameState* _internal_mutable_currentgamestate();
  public:
  void unsafe_arena_set_allocated_currentgamestate(
      ::MonopolyGameMessages::GameState* currentgamestate);
  ::MonopolyGameMessages::GameState* unsafe_arena_release_currentgamestate();
  // optional .MonopolyGameMessages.AwaitedResolve awaitedResolve = 2;
  bool has_awaitedresolve() const;
  void clear_awaitedresolve() ;
  const ::MonopolyGameMessages::AwaitedResolve& awaitedresolve() const;
  PROTOBUF_NODISCARD ::MonopolyGameMessages::AwaitedResolve* release_awaitedresolve();
  ::MonopolyGameMessages::AwaitedResolve* mutable_awaitedresolve();
  void set_allocated_awaitedresolve(::MonopolyGameMessages::AwaitedResolve* awaitedresolve);
  private:
  const ::MonopolyGameMessages::AwaitedResolve& _internal_awaitedresolve() const;
  ::MonopolyGameMessages::AwaitedResolve* _internal_mutable_awaitedresolve();
  public:
  void unsafe_arena_set_allocated_awaitedresolve(
      ::MonopolyGameMessages::AwaitedResolve* awaitedresolve);
  ::MonopolyGameMessages::AwaitedResolve* unsafe_arena_release_awaitedresolve();
  // optional .MonopolyGameMessages.AwaitedMessage awaitedSignal = 3;
  bool has_awaitedsignal() const;
  void clear_awaitedsignal() ;
  ::MonopolyGameMessages::AwaitedMessage awaitedsignal() const;
  void set_awaitedsignal(::MonopolyGameMessages::AwaitedMessage value);

  private:
  ::MonopolyGameMessages::AwaitedMessage _internal_awaitedsignal() const;
  void _internal_set_awaitedsignal(::MonopolyGameMessages::AwaitedMessage value);

  public:
  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.StateRefresh)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::MonopolyGameMessages::GameState* currentgamestate_;
    ::MonopolyGameMessages::AwaitedResolve* awaitedresolve_;
    int awaitedsignal_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};// -------------------------------------------------------------------

class BuyResolve final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.BuyResolve) */ {
 public:
  inline BuyResolve() : BuyResolve(nullptr) {}
  ~BuyResolve() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BuyResolve(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuyResolve(const BuyResolve& from);
  BuyResolve(BuyResolve&& from) noexcept
    : BuyResolve() {
    *this = ::std::move(from);
  }

  inline BuyResolve& operator=(const BuyResolve& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyResolve& operator=(BuyResolve&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuyResolve& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuyResolve* internal_default_instance() {
    return reinterpret_cast<const BuyResolve*>(
               &_BuyResolve_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BuyResolve& a, BuyResolve& b) {
    a.Swap(&b);
  }
  inline void Swap(BuyResolve* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuyResolve* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuyResolve* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuyResolve>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuyResolve& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BuyResolve& from) {
    BuyResolve::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuyResolve* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.BuyResolve";
  }
  protected:
  explicit BuyResolve(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsBoughtFieldNumber = 1,
  };
  // bool isBought = 1;
  void clear_isbought() ;
  bool isbought() const;
  void set_isbought(bool value);

  private:
  bool _internal_isbought() const;
  void _internal_set_isbought(bool value);

  public:
  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.BuyResolve)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool isbought_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};// -------------------------------------------------------------------

class DoSabotageResolve final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.DoSabotageResolve) */ {
 public:
  inline DoSabotageResolve() : DoSabotageResolve(nullptr) {}
  ~DoSabotageResolve() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DoSabotageResolve(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoSabotageResolve(const DoSabotageResolve& from);
  DoSabotageResolve(DoSabotageResolve&& from) noexcept
    : DoSabotageResolve() {
    *this = ::std::move(from);
  }

  inline DoSabotageResolve& operator=(const DoSabotageResolve& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoSabotageResolve& operator=(DoSabotageResolve&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoSabotageResolve& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoSabotageResolve* internal_default_instance() {
    return reinterpret_cast<const DoSabotageResolve*>(
               &_DoSabotageResolve_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DoSabotageResolve& a, DoSabotageResolve& b) {
    a.Swap(&b);
  }
  inline void Swap(DoSabotageResolve* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoSabotageResolve* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoSabotageResolve* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoSabotageResolve>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoSabotageResolve& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoSabotageResolve& from) {
    DoSabotageResolve::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoSabotageResolve* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.DoSabotageResolve";
  }
  protected:
  explicit DoSabotageResolve(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSabotagedFieldNumber = 1,
    kTileOrderFieldNumber = 2,
  };
  // bool isSabotaged = 1;
  void clear_issabotaged() ;
  bool issabotaged() const;
  void set_issabotaged(bool value);

  private:
  bool _internal_issabotaged() const;
  void _internal_set_issabotaged(bool value);

  public:
  // optional uint32 tileOrder = 2;
  bool has_tileorder() const;
  void clear_tileorder() ;
  ::uint32_t tileorder() const;
  void set_tileorder(::uint32_t value);

  private:
  ::uint32_t _internal_tileorder() const;
  void _internal_set_tileorder(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.DoSabotageResolve)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool issabotaged_;
    ::uint32_t tileorder_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};// -------------------------------------------------------------------

class BuyArrowResolve final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.BuyArrowResolve) */ {
 public:
  inline BuyArrowResolve() : BuyArrowResolve(nullptr) {}
  ~BuyArrowResolve() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BuyArrowResolve(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuyArrowResolve(const BuyArrowResolve& from);
  BuyArrowResolve(BuyArrowResolve&& from) noexcept
    : BuyArrowResolve() {
    *this = ::std::move(from);
  }

  inline BuyArrowResolve& operator=(const BuyArrowResolve& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyArrowResolve& operator=(BuyArrowResolve&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuyArrowResolve& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuyArrowResolve* internal_default_instance() {
    return reinterpret_cast<const BuyArrowResolve*>(
               &_BuyArrowResolve_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BuyArrowResolve& a, BuyArrowResolve& b) {
    a.Swap(&b);
  }
  inline void Swap(BuyArrowResolve* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuyArrowResolve* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuyArrowResolve* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuyArrowResolve>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuyArrowResolve& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BuyArrowResolve& from) {
    BuyArrowResolve::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuyArrowResolve* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.BuyArrowResolve";
  }
  protected:
  explicit BuyArrowResolve(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsBoughtFieldNumber = 1,
    kNewDirectionFieldNumber = 2,
  };
  // bool isBought = 1;
  void clear_isbought() ;
  bool isbought() const;
  void set_isbought(bool value);

  private:
  bool _internal_isbought() const;
  void _internal_set_isbought(bool value);

  public:
  // optional .MonopolyGameMessages.ArrowDirection newDirection = 2;
  bool has_newdirection() const;
  void clear_newdirection() ;
  ::MonopolyGameMessages::ArrowDirection newdirection() const;
  void set_newdirection(::MonopolyGameMessages::ArrowDirection value);

  private:
  ::MonopolyGameMessages::ArrowDirection _internal_newdirection() const;
  void _internal_set_newdirection(::MonopolyGameMessages::ArrowDirection value);

  public:
  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.BuyArrowResolve)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool isbought_;
    int newdirection_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};// -------------------------------------------------------------------

class DicesAreDrawn final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.DicesAreDrawn) */ {
 public:
  inline DicesAreDrawn() : DicesAreDrawn(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DicesAreDrawn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DicesAreDrawn(const DicesAreDrawn& from);
  DicesAreDrawn(DicesAreDrawn&& from) noexcept
    : DicesAreDrawn() {
    *this = ::std::move(from);
  }

  inline DicesAreDrawn& operator=(const DicesAreDrawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline DicesAreDrawn& operator=(DicesAreDrawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DicesAreDrawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const DicesAreDrawn* internal_default_instance() {
    return reinterpret_cast<const DicesAreDrawn*>(
               &_DicesAreDrawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DicesAreDrawn& a, DicesAreDrawn& b) {
    a.Swap(&b);
  }
  inline void Swap(DicesAreDrawn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DicesAreDrawn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DicesAreDrawn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DicesAreDrawn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DicesAreDrawn& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DicesAreDrawn& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.DicesAreDrawn";
  }
  protected:
  explicit DicesAreDrawn(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.DicesAreDrawn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};// -------------------------------------------------------------------

class PieceMovingIsDrawn final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.PieceMovingIsDrawn) */ {
 public:
  inline PieceMovingIsDrawn() : PieceMovingIsDrawn(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PieceMovingIsDrawn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PieceMovingIsDrawn(const PieceMovingIsDrawn& from);
  PieceMovingIsDrawn(PieceMovingIsDrawn&& from) noexcept
    : PieceMovingIsDrawn() {
    *this = ::std::move(from);
  }

  inline PieceMovingIsDrawn& operator=(const PieceMovingIsDrawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline PieceMovingIsDrawn& operator=(PieceMovingIsDrawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PieceMovingIsDrawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const PieceMovingIsDrawn* internal_default_instance() {
    return reinterpret_cast<const PieceMovingIsDrawn*>(
               &_PieceMovingIsDrawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PieceMovingIsDrawn& a, PieceMovingIsDrawn& b) {
    a.Swap(&b);
  }
  inline void Swap(PieceMovingIsDrawn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PieceMovingIsDrawn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PieceMovingIsDrawn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PieceMovingIsDrawn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PieceMovingIsDrawn& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PieceMovingIsDrawn& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.PieceMovingIsDrawn";
  }
  protected:
  explicit PieceMovingIsDrawn(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.PieceMovingIsDrawn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};// -------------------------------------------------------------------

class TimeForResolveOut final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.TimeForResolveOut) */ {
 public:
  inline TimeForResolveOut() : TimeForResolveOut(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TimeForResolveOut(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeForResolveOut(const TimeForResolveOut& from);
  TimeForResolveOut(TimeForResolveOut&& from) noexcept
    : TimeForResolveOut() {
    *this = ::std::move(from);
  }

  inline TimeForResolveOut& operator=(const TimeForResolveOut& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeForResolveOut& operator=(TimeForResolveOut&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeForResolveOut& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeForResolveOut* internal_default_instance() {
    return reinterpret_cast<const TimeForResolveOut*>(
               &_TimeForResolveOut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TimeForResolveOut& a, TimeForResolveOut& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeForResolveOut* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeForResolveOut* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeForResolveOut* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeForResolveOut>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TimeForResolveOut& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TimeForResolveOut& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.TimeForResolveOut";
  }
  protected:
  explicit TimeForResolveOut(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.TimeForResolveOut)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};// -------------------------------------------------------------------

class TimeForWaitOut final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.TimeForWaitOut) */ {
 public:
  inline TimeForWaitOut() : TimeForWaitOut(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TimeForWaitOut(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeForWaitOut(const TimeForWaitOut& from);
  TimeForWaitOut(TimeForWaitOut&& from) noexcept
    : TimeForWaitOut() {
    *this = ::std::move(from);
  }

  inline TimeForWaitOut& operator=(const TimeForWaitOut& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeForWaitOut& operator=(TimeForWaitOut&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeForWaitOut& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeForWaitOut* internal_default_instance() {
    return reinterpret_cast<const TimeForWaitOut*>(
               &_TimeForWaitOut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TimeForWaitOut& a, TimeForWaitOut& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeForWaitOut* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeForWaitOut* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeForWaitOut* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeForWaitOut>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TimeForWaitOut& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TimeForWaitOut& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.TimeForWaitOut";
  }
  protected:
  explicit TimeForWaitOut(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.TimeForWaitOut)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};// -------------------------------------------------------------------

class GameState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.GameState) */ {
 public:
  inline GameState() : GameState(nullptr) {}
  ~GameState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GameState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameState(const GameState& from);
  GameState(GameState&& from) noexcept
    : GameState() {
    *this = ::std::move(from);
  }

  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameState& operator=(GameState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameState& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameState* internal_default_instance() {
    return reinterpret_cast<const GameState*>(
               &_GameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GameState& a, GameState& b) {
    a.Swap(&b);
  }
  inline void Swap(GameState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameState& from) {
    GameState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.GameState";
  }
  protected:
  explicit GameState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTraceFieldNumber = 5,
    kMapFieldNumber = 7,
    kPlayersFieldNumber = 8,
    kDicesFieldNumber = 6,
    kStateFieldNumber = 1,
    kCurrentTurnFieldNumber = 2,
    kCurrentStageFieldNumber = 3,
    kWhoseTurnFieldNumber = 4,
  };
  // repeated uint32 trace = 5;
  int trace_size() const;
  private:
  int _internal_trace_size() const;

  public:
  void clear_trace() ;
  ::uint32_t trace(int index) const;
  void set_trace(int index, ::uint32_t value);
  void add_trace(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& trace() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* mutable_trace();

  private:
  ::uint32_t _internal_trace(int index) const;
  void _internal_add_trace(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& _internal_trace() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* _internal_mutable_trace();

  public:
  // repeated .MonopolyGameMessages.Tile map = 7;
  int map_size() const;
  private:
  int _internal_map_size() const;

  public:
  void clear_map() ;
  ::MonopolyGameMessages::Tile* mutable_map(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::Tile >*
      mutable_map();
  private:
  const ::MonopolyGameMessages::Tile& _internal_map(int index) const;
  ::MonopolyGameMessages::Tile* _internal_add_map();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::Tile>& _internal_map() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::Tile>* _internal_mutable_map();
  public:
  const ::MonopolyGameMessages::Tile& map(int index) const;
  ::MonopolyGameMessages::Tile* add_map();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::Tile >&
      map() const;
  // repeated .MonopolyGameMessages.Player players = 8;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::MonopolyGameMessages::Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::Player >*
      mutable_players();
  private:
  const ::MonopolyGameMessages::Player& _internal_players(int index) const;
  ::MonopolyGameMessages::Player* _internal_add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::Player>& _internal_players() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::Player>* _internal_mutable_players();
  public:
  const ::MonopolyGameMessages::Player& players(int index) const;
  ::MonopolyGameMessages::Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::Player >&
      players() const;
  // .MonopolyGameMessages.Dices dices = 6;
  bool has_dices() const;
  void clear_dices() ;
  const ::MonopolyGameMessages::Dices& dices() const;
  PROTOBUF_NODISCARD ::MonopolyGameMessages::Dices* release_dices();
  ::MonopolyGameMessages::Dices* mutable_dices();
  void set_allocated_dices(::MonopolyGameMessages::Dices* dices);
  private:
  const ::MonopolyGameMessages::Dices& _internal_dices() const;
  ::MonopolyGameMessages::Dices* _internal_mutable_dices();
  public:
  void unsafe_arena_set_allocated_dices(
      ::MonopolyGameMessages::Dices* dices);
  ::MonopolyGameMessages::Dices* unsafe_arena_release_dices();
  // .MonopolyGameMessages.State state = 1;
  void clear_state() ;
  ::MonopolyGameMessages::State state() const;
  void set_state(::MonopolyGameMessages::State value);

  private:
  ::MonopolyGameMessages::State _internal_state() const;
  void _internal_set_state(::MonopolyGameMessages::State value);

  public:
  // uint32 currentTurn = 2;
  void clear_currentturn() ;
  ::uint32_t currentturn() const;
  void set_currentturn(::uint32_t value);

  private:
  ::uint32_t _internal_currentturn() const;
  void _internal_set_currentturn(::uint32_t value);

  public:
  // uint32 currentStage = 3;
  void clear_currentstage() ;
  ::uint32_t currentstage() const;
  void set_currentstage(::uint32_t value);

  private:
  ::uint32_t _internal_currentstage() const;
  void _internal_set_currentstage(::uint32_t value);

  public:
  // optional .MonopolyGameMessages.PlayerNumber whoseTurn = 4;
  bool has_whoseturn() const;
  void clear_whoseturn() ;
  ::MonopolyGameMessages::PlayerNumber whoseturn() const;
  void set_whoseturn(::MonopolyGameMessages::PlayerNumber value);

  private:
  ::MonopolyGameMessages::PlayerNumber _internal_whoseturn() const;
  void _internal_set_whoseturn(::MonopolyGameMessages::PlayerNumber value);

  public:
  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.GameState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t> trace_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _trace_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::Tile > map_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::Player > players_;
    ::MonopolyGameMessages::Dices* dices_;
    int state_;
    ::uint32_t currentturn_;
    ::uint32_t currentstage_;
    int whoseturn_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};// -------------------------------------------------------------------

class AwaitedResolve final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.AwaitedResolve) */ {
 public:
  inline AwaitedResolve() : AwaitedResolve(nullptr) {}
  ~AwaitedResolve() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AwaitedResolve(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AwaitedResolve(const AwaitedResolve& from);
  AwaitedResolve(AwaitedResolve&& from) noexcept
    : AwaitedResolve() {
    *this = ::std::move(from);
  }

  inline AwaitedResolve& operator=(const AwaitedResolve& from) {
    CopyFrom(from);
    return *this;
  }
  inline AwaitedResolve& operator=(AwaitedResolve&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AwaitedResolve& default_instance() {
    return *internal_default_instance();
  }
  static inline const AwaitedResolve* internal_default_instance() {
    return reinterpret_cast<const AwaitedResolve*>(
               &_AwaitedResolve_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AwaitedResolve& a, AwaitedResolve& b) {
    a.Swap(&b);
  }
  inline void Swap(AwaitedResolve* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AwaitedResolve* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AwaitedResolve* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AwaitedResolve>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AwaitedResolve& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AwaitedResolve& from) {
    AwaitedResolve::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AwaitedResolve* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.AwaitedResolve";
  }
  protected:
  explicit AwaitedResolve(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetFieldNumber = 2,
    kAwaitFieldNumber = 1,
  };
  // .MonopolyGameMessages.Tile target = 2;
  bool has_target() const;
  void clear_target() ;
  const ::MonopolyGameMessages::Tile& target() const;
  PROTOBUF_NODISCARD ::MonopolyGameMessages::Tile* release_target();
  ::MonopolyGameMessages::Tile* mutable_target();
  void set_allocated_target(::MonopolyGameMessages::Tile* target);
  private:
  const ::MonopolyGameMessages::Tile& _internal_target() const;
  ::MonopolyGameMessages::Tile* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::MonopolyGameMessages::Tile* target);
  ::MonopolyGameMessages::Tile* unsafe_arena_release_target();
  // .MonopolyGameMessages.AwaitedMessage await = 1;
  void clear_await() ;
  ::MonopolyGameMessages::AwaitedMessage await() const;
  void set_await(::MonopolyGameMessages::AwaitedMessage value);

  private:
  ::MonopolyGameMessages::AwaitedMessage _internal_await() const;
  void _internal_set_await(::MonopolyGameMessages::AwaitedMessage value);

  public:
  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.AwaitedResolve)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::MonopolyGameMessages::Tile* target_;
    int await_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};// -------------------------------------------------------------------

class TileStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.TileStat) */ {
 public:
  inline TileStat() : TileStat(nullptr) {}
  ~TileStat() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TileStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TileStat(const TileStat& from);
  TileStat(TileStat&& from) noexcept
    : TileStat() {
    *this = ::std::move(from);
  }

  inline TileStat& operator=(const TileStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline TileStat& operator=(TileStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TileStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const TileStat* internal_default_instance() {
    return reinterpret_cast<const TileStat*>(
               &_TileStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TileStat& a, TileStat& b) {
    a.Swap(&b);
  }
  inline void Swap(TileStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TileStat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TileStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TileStat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TileStat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TileStat& from) {
    TileStat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TileStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.TileStat";
  }
  protected:
  explicit TileStat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .MonopolyGameMessages.TileType type = 1;
  void clear_type() ;
  ::MonopolyGameMessages::TileType type() const;
  void set_type(::MonopolyGameMessages::TileType value);

  private:
  ::MonopolyGameMessages::TileType _internal_type() const;
  void _internal_set_type(::MonopolyGameMessages::TileType value);

  public:
  // uint32 value = 2;
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.TileStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    ::uint32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};// -------------------------------------------------------------------

class Dices final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.Dices) */ {
 public:
  inline Dices() : Dices(nullptr) {}
  ~Dices() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Dices(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dices(const Dices& from);
  Dices(Dices&& from) noexcept
    : Dices() {
    *this = ::std::move(from);
  }

  inline Dices& operator=(const Dices& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dices& operator=(Dices&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dices& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dices* internal_default_instance() {
    return reinterpret_cast<const Dices*>(
               &_Dices_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Dices& a, Dices& b) {
    a.Swap(&b);
  }
  inline void Swap(Dices* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dices* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dices* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dices>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dices& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Dices& from) {
    Dices::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dices* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.Dices";
  }
  protected:
  explicit Dices(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftFieldNumber = 1,
    kRightFieldNumber = 2,
  };
  // uint32 left = 1;
  void clear_left() ;
  ::uint32_t left() const;
  void set_left(::uint32_t value);

  private:
  ::uint32_t _internal_left() const;
  void _internal_set_left(::uint32_t value);

  public:
  // uint32 right = 2;
  void clear_right() ;
  ::uint32_t right() const;
  void set_right(::uint32_t value);

  private:
  ::uint32_t _internal_right() const;
  void _internal_set_right(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.Dices)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t left_;
    ::uint32_t right_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};// -------------------------------------------------------------------

class Tile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.Tile) */ {
 public:
  inline Tile() : Tile(nullptr) {}
  ~Tile() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Tile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tile(const Tile& from);
  Tile(Tile&& from) noexcept
    : Tile() {
    *this = ::std::move(from);
  }

  inline Tile& operator=(const Tile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tile& operator=(Tile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tile& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tile* internal_default_instance() {
    return reinterpret_cast<const Tile*>(
               &_Tile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Tile& a, Tile& b) {
    a.Swap(&b);
  }
  inline void Swap(Tile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tile& from) {
    Tile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.Tile";
  }
  protected:
  explicit Tile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPiecesOnPositionFieldNumber = 6,
    kAllowDirectionsFieldNumber = 10,
    kOrderFieldNumber = 1,
    kTypeFieldNumber = 2,
    kOwnerFieldNumber = 3,
    kMinDisplayStageFieldNumber = 4,
    kMinActivationStageFieldNumber = 5,
    kCostForYouFieldNumber = 7,
    kIncomeForOwnerFieldNumber = 8,
    kDirectionFieldNumber = 9,
  };
  // repeated .MonopolyGameMessages.PlayerNumber piecesOnPosition = 6;
  int piecesonposition_size() const;
  private:
  int _internal_piecesonposition_size() const;

  public:
  void clear_piecesonposition() ;
  public:
  ::MonopolyGameMessages::PlayerNumber piecesonposition(int index) const;
  void set_piecesonposition(int index, ::MonopolyGameMessages::PlayerNumber value);
  void add_piecesonposition(::MonopolyGameMessages::PlayerNumber value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& piecesonposition() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_piecesonposition();

  private:
  ::MonopolyGameMessages::PlayerNumber _internal_piecesonposition(int index) const;
  void _internal_add_piecesonposition(::MonopolyGameMessages::PlayerNumber value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& _internal_piecesonposition() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_piecesonposition();

  public:
  // repeated .MonopolyGameMessages.ArrowDirection allowDirections = 10;
  int allowdirections_size() const;
  private:
  int _internal_allowdirections_size() const;

  public:
  void clear_allowdirections() ;
  public:
  ::MonopolyGameMessages::ArrowDirection allowdirections(int index) const;
  void set_allowdirections(int index, ::MonopolyGameMessages::ArrowDirection value);
  void add_allowdirections(::MonopolyGameMessages::ArrowDirection value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& allowdirections() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_allowdirections();

  private:
  ::MonopolyGameMessages::ArrowDirection _internal_allowdirections(int index) const;
  void _internal_add_allowdirections(::MonopolyGameMessages::ArrowDirection value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& _internal_allowdirections() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_allowdirections();

  public:
  // uint32 order = 1;
  void clear_order() ;
  ::uint32_t order() const;
  void set_order(::uint32_t value);

  private:
  ::uint32_t _internal_order() const;
  void _internal_set_order(::uint32_t value);

  public:
  // .MonopolyGameMessages.TileType type = 2;
  void clear_type() ;
  ::MonopolyGameMessages::TileType type() const;
  void set_type(::MonopolyGameMessages::TileType value);

  private:
  ::MonopolyGameMessages::TileType _internal_type() const;
  void _internal_set_type(::MonopolyGameMessages::TileType value);

  public:
  // .MonopolyGameMessages.PlayerNumber owner = 3;
  void clear_owner() ;
  ::MonopolyGameMessages::PlayerNumber owner() const;
  void set_owner(::MonopolyGameMessages::PlayerNumber value);

  private:
  ::MonopolyGameMessages::PlayerNumber _internal_owner() const;
  void _internal_set_owner(::MonopolyGameMessages::PlayerNumber value);

  public:
  // uint32 minDisplayStage = 4;
  void clear_mindisplaystage() ;
  ::uint32_t mindisplaystage() const;
  void set_mindisplaystage(::uint32_t value);

  private:
  ::uint32_t _internal_mindisplaystage() const;
  void _internal_set_mindisplaystage(::uint32_t value);

  public:
  // uint32 minActivationStage = 5;
  void clear_minactivationstage() ;
  ::uint32_t minactivationstage() const;
  void set_minactivationstage(::uint32_t value);

  private:
  ::uint32_t _internal_minactivationstage() const;
  void _internal_set_minactivationstage(::uint32_t value);

  public:
  // uint32 costForYou = 7;
  void clear_costforyou() ;
  ::uint32_t costforyou() const;
  void set_costforyou(::uint32_t value);

  private:
  ::uint32_t _internal_costforyou() const;
  void _internal_set_costforyou(::uint32_t value);

  public:
  // uint32 incomeForOwner = 8;
  void clear_incomeforowner() ;
  ::uint32_t incomeforowner() const;
  void set_incomeforowner(::uint32_t value);

  private:
  ::uint32_t _internal_incomeforowner() const;
  void _internal_set_incomeforowner(::uint32_t value);

  public:
  // optional .MonopolyGameMessages.ArrowDirection direction = 9;
  bool has_direction() const;
  void clear_direction() ;
  ::MonopolyGameMessages::ArrowDirection direction() const;
  void set_direction(::MonopolyGameMessages::ArrowDirection value);

  private:
  ::MonopolyGameMessages::ArrowDirection _internal_direction() const;
  void _internal_set_direction(::MonopolyGameMessages::ArrowDirection value);

  public:
  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.Tile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> piecesonposition_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _piecesonposition_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> allowdirections_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _allowdirections_cached_byte_size_;
    ::uint32_t order_;
    int type_;
    int owner_;
    ::uint32_t mindisplaystage_;
    ::uint32_t minactivationstage_;
    ::uint32_t costforyou_;
    ::uint32_t incomeforowner_;
    int direction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};// -------------------------------------------------------------------

class Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MonopolyGameMessages.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Player& from) {
    Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MonopolyGameMessages.Player";
  }
  protected:
  explicit Player(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 2,
    kUserIDFieldNumber = 1,
    kOrderFieldNumber = 3,
    kIncomeFieldNumber = 4,
    kBalanceFieldNumber = 5,
  };
  // string nickname = 2;
  void clear_nickname() ;
  const std::string& nickname() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* ptr);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // uint32 userID = 1;
  void clear_userid() ;
  ::uint32_t userid() const;
  void set_userid(::uint32_t value);

  private:
  ::uint32_t _internal_userid() const;
  void _internal_set_userid(::uint32_t value);

  public:
  // .MonopolyGameMessages.PlayerNumber order = 3;
  void clear_order() ;
  ::MonopolyGameMessages::PlayerNumber order() const;
  void set_order(::MonopolyGameMessages::PlayerNumber value);

  private:
  ::MonopolyGameMessages::PlayerNumber _internal_order() const;
  void _internal_set_order(::MonopolyGameMessages::PlayerNumber value);

  public:
  // uint32 income = 4;
  void clear_income() ;
  ::uint32_t income() const;
  void set_income(::uint32_t value);

  private:
  ::uint32_t _internal_income() const;
  void _internal_set_income(::uint32_t value);

  public:
  // uint32 balance = 5;
  void clear_balance() ;
  ::uint32_t balance() const;
  void set_balance(::uint32_t value);

  private:
  ::uint32_t _internal_balance() const;
  void _internal_set_balance(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MonopolyGameMessages.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    ::uint32_t userid_;
    int order_;
    ::uint32_t income_;
    ::uint32_t balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MonopolyGameMessages_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ClientHello

// uint32 id = 1;
inline void ClientHello::clear_id() {
  _impl_.id_ = 0u;
}
inline ::uint32_t ClientHello::id() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.ClientHello.id)
  return _internal_id();
}
inline void ClientHello::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.ClientHello.id)
}
inline ::uint32_t ClientHello::_internal_id() const {
  return _impl_.id_;
}
inline void ClientHello::_internal_set_id(::uint32_t value) {
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// ServerHello

// uint32 lobbyID = 1;
inline void ServerHello::clear_lobbyid() {
  _impl_.lobbyid_ = 0u;
}
inline ::uint32_t ServerHello::lobbyid() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.ServerHello.lobbyID)
  return _internal_lobbyid();
}
inline void ServerHello::set_lobbyid(::uint32_t value) {
  _internal_set_lobbyid(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.ServerHello.lobbyID)
}
inline ::uint32_t ServerHello::_internal_lobbyid() const {
  return _impl_.lobbyid_;
}
inline void ServerHello::_internal_set_lobbyid(::uint32_t value) {
  ;
  _impl_.lobbyid_ = value;
}

// string lobbyName = 2;
inline void ServerHello::clear_lobbyname() {
  _impl_.lobbyname_.ClearToEmpty();
}
inline const std::string& ServerHello::lobbyname() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.ServerHello.lobbyName)
  return _internal_lobbyname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerHello::set_lobbyname(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.lobbyname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.ServerHello.lobbyName)
}
inline std::string* ServerHello::mutable_lobbyname() {
  std::string* _s = _internal_mutable_lobbyname();
  // @@protoc_insertion_point(field_mutable:MonopolyGameMessages.ServerHello.lobbyName)
  return _s;
}
inline const std::string& ServerHello::_internal_lobbyname() const {
  return _impl_.lobbyname_.Get();
}
inline void ServerHello::_internal_set_lobbyname(const std::string& value) {
  ;


  _impl_.lobbyname_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerHello::_internal_mutable_lobbyname() {
  ;
  return _impl_.lobbyname_.Mutable( GetArenaForAllocation());
}
inline std::string* ServerHello::release_lobbyname() {
  // @@protoc_insertion_point(field_release:MonopolyGameMessages.ServerHello.lobbyName)
  return _impl_.lobbyname_.Release();
}
inline void ServerHello::set_allocated_lobbyname(std::string* value) {
  _impl_.lobbyname_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lobbyname_.IsDefault()) {
          _impl_.lobbyname_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MonopolyGameMessages.ServerHello.lobbyName)
}

// uint32 timeForResolve = 3;
inline void ServerHello::clear_timeforresolve() {
  _impl_.timeforresolve_ = 0u;
}
inline ::uint32_t ServerHello::timeforresolve() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.ServerHello.timeForResolve)
  return _internal_timeforresolve();
}
inline void ServerHello::set_timeforresolve(::uint32_t value) {
  _internal_set_timeforresolve(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.ServerHello.timeForResolve)
}
inline ::uint32_t ServerHello::_internal_timeforresolve() const {
  return _impl_.timeforresolve_;
}
inline void ServerHello::_internal_set_timeforresolve(::uint32_t value) {
  ;
  _impl_.timeforresolve_ = value;
}

// repeated .MonopolyGameMessages.Player players = 4;
inline int ServerHello::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int ServerHello::players_size() const {
  return _internal_players_size();
}
inline void ServerHello::clear_players() {
  _internal_mutable_players()->Clear();
}
inline ::MonopolyGameMessages::Player* ServerHello::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:MonopolyGameMessages.ServerHello.players)
  return _internal_mutable_players()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::Player >*
ServerHello::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:MonopolyGameMessages.ServerHello.players)
  return _internal_mutable_players();
}
inline const ::MonopolyGameMessages::Player& ServerHello::_internal_players(int index) const {
  return _internal_players().Get(index);
}
inline const ::MonopolyGameMessages::Player& ServerHello::players(int index) const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.ServerHello.players)
  return _internal_players(index);
}
inline ::MonopolyGameMessages::Player* ServerHello::_internal_add_players() {
  return _internal_mutable_players()->Add();
}
inline ::MonopolyGameMessages::Player* ServerHello::add_players() {
  ::MonopolyGameMessages::Player* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:MonopolyGameMessages.ServerHello.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::Player >&
ServerHello::players() const {
  // @@protoc_insertion_point(field_list:MonopolyGameMessages.ServerHello.players)
  return _internal_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::Player>&
ServerHello::_internal_players() const {
  return _impl_.players_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::Player>*
ServerHello::_internal_mutable_players() {
  return &_impl_.players_;
}

// repeated .MonopolyGameMessages.TileStat baseCost = 5;
inline int ServerHello::_internal_basecost_size() const {
  return _impl_.basecost_.size();
}
inline int ServerHello::basecost_size() const {
  return _internal_basecost_size();
}
inline void ServerHello::clear_basecost() {
  _internal_mutable_basecost()->Clear();
}
inline ::MonopolyGameMessages::TileStat* ServerHello::mutable_basecost(int index) {
  // @@protoc_insertion_point(field_mutable:MonopolyGameMessages.ServerHello.baseCost)
  return _internal_mutable_basecost()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::TileStat >*
ServerHello::mutable_basecost() {
  // @@protoc_insertion_point(field_mutable_list:MonopolyGameMessages.ServerHello.baseCost)
  return _internal_mutable_basecost();
}
inline const ::MonopolyGameMessages::TileStat& ServerHello::_internal_basecost(int index) const {
  return _internal_basecost().Get(index);
}
inline const ::MonopolyGameMessages::TileStat& ServerHello::basecost(int index) const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.ServerHello.baseCost)
  return _internal_basecost(index);
}
inline ::MonopolyGameMessages::TileStat* ServerHello::_internal_add_basecost() {
  return _internal_mutable_basecost()->Add();
}
inline ::MonopolyGameMessages::TileStat* ServerHello::add_basecost() {
  ::MonopolyGameMessages::TileStat* _add = _internal_add_basecost();
  // @@protoc_insertion_point(field_add:MonopolyGameMessages.ServerHello.baseCost)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::TileStat >&
ServerHello::basecost() const {
  // @@protoc_insertion_point(field_list:MonopolyGameMessages.ServerHello.baseCost)
  return _internal_basecost();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::TileStat>&
ServerHello::_internal_basecost() const {
  return _impl_.basecost_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::TileStat>*
ServerHello::_internal_mutable_basecost() {
  return &_impl_.basecost_;
}

// repeated .MonopolyGameMessages.TileStat baseIncome = 6;
inline int ServerHello::_internal_baseincome_size() const {
  return _impl_.baseincome_.size();
}
inline int ServerHello::baseincome_size() const {
  return _internal_baseincome_size();
}
inline void ServerHello::clear_baseincome() {
  _internal_mutable_baseincome()->Clear();
}
inline ::MonopolyGameMessages::TileStat* ServerHello::mutable_baseincome(int index) {
  // @@protoc_insertion_point(field_mutable:MonopolyGameMessages.ServerHello.baseIncome)
  return _internal_mutable_baseincome()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::TileStat >*
ServerHello::mutable_baseincome() {
  // @@protoc_insertion_point(field_mutable_list:MonopolyGameMessages.ServerHello.baseIncome)
  return _internal_mutable_baseincome();
}
inline const ::MonopolyGameMessages::TileStat& ServerHello::_internal_baseincome(int index) const {
  return _internal_baseincome().Get(index);
}
inline const ::MonopolyGameMessages::TileStat& ServerHello::baseincome(int index) const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.ServerHello.baseIncome)
  return _internal_baseincome(index);
}
inline ::MonopolyGameMessages::TileStat* ServerHello::_internal_add_baseincome() {
  return _internal_mutable_baseincome()->Add();
}
inline ::MonopolyGameMessages::TileStat* ServerHello::add_baseincome() {
  ::MonopolyGameMessages::TileStat* _add = _internal_add_baseincome();
  // @@protoc_insertion_point(field_add:MonopolyGameMessages.ServerHello.baseIncome)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::TileStat >&
ServerHello::baseincome() const {
  // @@protoc_insertion_point(field_list:MonopolyGameMessages.ServerHello.baseIncome)
  return _internal_baseincome();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::TileStat>&
ServerHello::_internal_baseincome() const {
  return _impl_.baseincome_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::TileStat>*
ServerHello::_internal_mutable_baseincome() {
  return &_impl_.baseincome_;
}

// .MonopolyGameMessages.GameState currentGameState = 7;
inline bool ServerHello::has_currentgamestate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.currentgamestate_ != nullptr);
  return value;
}
inline void ServerHello::clear_currentgamestate() {
  if (_impl_.currentgamestate_ != nullptr) _impl_.currentgamestate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MonopolyGameMessages::GameState& ServerHello::_internal_currentgamestate() const {
  const ::MonopolyGameMessages::GameState* p = _impl_.currentgamestate_;
  return p != nullptr ? *p : reinterpret_cast<const ::MonopolyGameMessages::GameState&>(
      ::MonopolyGameMessages::_GameState_default_instance_);
}
inline const ::MonopolyGameMessages::GameState& ServerHello::currentgamestate() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.ServerHello.currentGameState)
  return _internal_currentgamestate();
}
inline void ServerHello::unsafe_arena_set_allocated_currentgamestate(
    ::MonopolyGameMessages::GameState* currentgamestate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.currentgamestate_);
  }
  _impl_.currentgamestate_ = currentgamestate;
  if (currentgamestate) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MonopolyGameMessages.ServerHello.currentGameState)
}
inline ::MonopolyGameMessages::GameState* ServerHello::release_currentgamestate() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MonopolyGameMessages::GameState* temp = _impl_.currentgamestate_;
  _impl_.currentgamestate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MonopolyGameMessages::GameState* ServerHello::unsafe_arena_release_currentgamestate() {
  // @@protoc_insertion_point(field_release:MonopolyGameMessages.ServerHello.currentGameState)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MonopolyGameMessages::GameState* temp = _impl_.currentgamestate_;
  _impl_.currentgamestate_ = nullptr;
  return temp;
}
inline ::MonopolyGameMessages::GameState* ServerHello::_internal_mutable_currentgamestate() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.currentgamestate_ == nullptr) {
    auto* p = CreateMaybeMessage<::MonopolyGameMessages::GameState>(GetArenaForAllocation());
    _impl_.currentgamestate_ = p;
  }
  return _impl_.currentgamestate_;
}
inline ::MonopolyGameMessages::GameState* ServerHello::mutable_currentgamestate() {
  ::MonopolyGameMessages::GameState* _msg = _internal_mutable_currentgamestate();
  // @@protoc_insertion_point(field_mutable:MonopolyGameMessages.ServerHello.currentGameState)
  return _msg;
}
inline void ServerHello::set_allocated_currentgamestate(::MonopolyGameMessages::GameState* currentgamestate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.currentgamestate_;
  }
  if (currentgamestate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(currentgamestate);
    if (message_arena != submessage_arena) {
      currentgamestate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, currentgamestate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.currentgamestate_ = currentgamestate;
  // @@protoc_insertion_point(field_set_allocated:MonopolyGameMessages.ServerHello.currentGameState)
}

// -------------------------------------------------------------------

// StateRefresh

// .MonopolyGameMessages.GameState currentGameState = 1;
inline bool StateRefresh::has_currentgamestate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.currentgamestate_ != nullptr);
  return value;
}
inline void StateRefresh::clear_currentgamestate() {
  if (_impl_.currentgamestate_ != nullptr) _impl_.currentgamestate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MonopolyGameMessages::GameState& StateRefresh::_internal_currentgamestate() const {
  const ::MonopolyGameMessages::GameState* p = _impl_.currentgamestate_;
  return p != nullptr ? *p : reinterpret_cast<const ::MonopolyGameMessages::GameState&>(
      ::MonopolyGameMessages::_GameState_default_instance_);
}
inline const ::MonopolyGameMessages::GameState& StateRefresh::currentgamestate() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.StateRefresh.currentGameState)
  return _internal_currentgamestate();
}
inline void StateRefresh::unsafe_arena_set_allocated_currentgamestate(
    ::MonopolyGameMessages::GameState* currentgamestate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.currentgamestate_);
  }
  _impl_.currentgamestate_ = currentgamestate;
  if (currentgamestate) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MonopolyGameMessages.StateRefresh.currentGameState)
}
inline ::MonopolyGameMessages::GameState* StateRefresh::release_currentgamestate() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MonopolyGameMessages::GameState* temp = _impl_.currentgamestate_;
  _impl_.currentgamestate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MonopolyGameMessages::GameState* StateRefresh::unsafe_arena_release_currentgamestate() {
  // @@protoc_insertion_point(field_release:MonopolyGameMessages.StateRefresh.currentGameState)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MonopolyGameMessages::GameState* temp = _impl_.currentgamestate_;
  _impl_.currentgamestate_ = nullptr;
  return temp;
}
inline ::MonopolyGameMessages::GameState* StateRefresh::_internal_mutable_currentgamestate() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.currentgamestate_ == nullptr) {
    auto* p = CreateMaybeMessage<::MonopolyGameMessages::GameState>(GetArenaForAllocation());
    _impl_.currentgamestate_ = p;
  }
  return _impl_.currentgamestate_;
}
inline ::MonopolyGameMessages::GameState* StateRefresh::mutable_currentgamestate() {
  ::MonopolyGameMessages::GameState* _msg = _internal_mutable_currentgamestate();
  // @@protoc_insertion_point(field_mutable:MonopolyGameMessages.StateRefresh.currentGameState)
  return _msg;
}
inline void StateRefresh::set_allocated_currentgamestate(::MonopolyGameMessages::GameState* currentgamestate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.currentgamestate_;
  }
  if (currentgamestate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(currentgamestate);
    if (message_arena != submessage_arena) {
      currentgamestate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, currentgamestate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.currentgamestate_ = currentgamestate;
  // @@protoc_insertion_point(field_set_allocated:MonopolyGameMessages.StateRefresh.currentGameState)
}

// optional .MonopolyGameMessages.AwaitedResolve awaitedResolve = 2;
inline bool StateRefresh::has_awaitedresolve() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.awaitedresolve_ != nullptr);
  return value;
}
inline void StateRefresh::clear_awaitedresolve() {
  if (_impl_.awaitedresolve_ != nullptr) _impl_.awaitedresolve_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::MonopolyGameMessages::AwaitedResolve& StateRefresh::_internal_awaitedresolve() const {
  const ::MonopolyGameMessages::AwaitedResolve* p = _impl_.awaitedresolve_;
  return p != nullptr ? *p : reinterpret_cast<const ::MonopolyGameMessages::AwaitedResolve&>(
      ::MonopolyGameMessages::_AwaitedResolve_default_instance_);
}
inline const ::MonopolyGameMessages::AwaitedResolve& StateRefresh::awaitedresolve() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.StateRefresh.awaitedResolve)
  return _internal_awaitedresolve();
}
inline void StateRefresh::unsafe_arena_set_allocated_awaitedresolve(
    ::MonopolyGameMessages::AwaitedResolve* awaitedresolve) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.awaitedresolve_);
  }
  _impl_.awaitedresolve_ = awaitedresolve;
  if (awaitedresolve) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MonopolyGameMessages.StateRefresh.awaitedResolve)
}
inline ::MonopolyGameMessages::AwaitedResolve* StateRefresh::release_awaitedresolve() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::MonopolyGameMessages::AwaitedResolve* temp = _impl_.awaitedresolve_;
  _impl_.awaitedresolve_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MonopolyGameMessages::AwaitedResolve* StateRefresh::unsafe_arena_release_awaitedresolve() {
  // @@protoc_insertion_point(field_release:MonopolyGameMessages.StateRefresh.awaitedResolve)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::MonopolyGameMessages::AwaitedResolve* temp = _impl_.awaitedresolve_;
  _impl_.awaitedresolve_ = nullptr;
  return temp;
}
inline ::MonopolyGameMessages::AwaitedResolve* StateRefresh::_internal_mutable_awaitedresolve() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.awaitedresolve_ == nullptr) {
    auto* p = CreateMaybeMessage<::MonopolyGameMessages::AwaitedResolve>(GetArenaForAllocation());
    _impl_.awaitedresolve_ = p;
  }
  return _impl_.awaitedresolve_;
}
inline ::MonopolyGameMessages::AwaitedResolve* StateRefresh::mutable_awaitedresolve() {
  ::MonopolyGameMessages::AwaitedResolve* _msg = _internal_mutable_awaitedresolve();
  // @@protoc_insertion_point(field_mutable:MonopolyGameMessages.StateRefresh.awaitedResolve)
  return _msg;
}
inline void StateRefresh::set_allocated_awaitedresolve(::MonopolyGameMessages::AwaitedResolve* awaitedresolve) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.awaitedresolve_;
  }
  if (awaitedresolve) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(awaitedresolve);
    if (message_arena != submessage_arena) {
      awaitedresolve = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, awaitedresolve, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.awaitedresolve_ = awaitedresolve;
  // @@protoc_insertion_point(field_set_allocated:MonopolyGameMessages.StateRefresh.awaitedResolve)
}

// optional .MonopolyGameMessages.AwaitedMessage awaitedSignal = 3;
inline bool StateRefresh::has_awaitedsignal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StateRefresh::clear_awaitedsignal() {
  _impl_.awaitedsignal_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::MonopolyGameMessages::AwaitedMessage StateRefresh::awaitedsignal() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.StateRefresh.awaitedSignal)
  return _internal_awaitedsignal();
}
inline void StateRefresh::set_awaitedsignal(::MonopolyGameMessages::AwaitedMessage value) {
   _internal_set_awaitedsignal(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.StateRefresh.awaitedSignal)
}
inline ::MonopolyGameMessages::AwaitedMessage StateRefresh::_internal_awaitedsignal() const {
  return static_cast<::MonopolyGameMessages::AwaitedMessage>(_impl_.awaitedsignal_);
}
inline void StateRefresh::_internal_set_awaitedsignal(::MonopolyGameMessages::AwaitedMessage value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.awaitedsignal_ = value;
}

// -------------------------------------------------------------------

// BuyResolve

// bool isBought = 1;
inline void BuyResolve::clear_isbought() {
  _impl_.isbought_ = false;
}
inline bool BuyResolve::isbought() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.BuyResolve.isBought)
  return _internal_isbought();
}
inline void BuyResolve::set_isbought(bool value) {
  _internal_set_isbought(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.BuyResolve.isBought)
}
inline bool BuyResolve::_internal_isbought() const {
  return _impl_.isbought_;
}
inline void BuyResolve::_internal_set_isbought(bool value) {
  ;
  _impl_.isbought_ = value;
}

// -------------------------------------------------------------------

// DoSabotageResolve

// bool isSabotaged = 1;
inline void DoSabotageResolve::clear_issabotaged() {
  _impl_.issabotaged_ = false;
}
inline bool DoSabotageResolve::issabotaged() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.DoSabotageResolve.isSabotaged)
  return _internal_issabotaged();
}
inline void DoSabotageResolve::set_issabotaged(bool value) {
  _internal_set_issabotaged(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.DoSabotageResolve.isSabotaged)
}
inline bool DoSabotageResolve::_internal_issabotaged() const {
  return _impl_.issabotaged_;
}
inline void DoSabotageResolve::_internal_set_issabotaged(bool value) {
  ;
  _impl_.issabotaged_ = value;
}

// optional uint32 tileOrder = 2;
inline bool DoSabotageResolve::has_tileorder() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DoSabotageResolve::clear_tileorder() {
  _impl_.tileorder_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t DoSabotageResolve::tileorder() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.DoSabotageResolve.tileOrder)
  return _internal_tileorder();
}
inline void DoSabotageResolve::set_tileorder(::uint32_t value) {
  _internal_set_tileorder(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.DoSabotageResolve.tileOrder)
}
inline ::uint32_t DoSabotageResolve::_internal_tileorder() const {
  return _impl_.tileorder_;
}
inline void DoSabotageResolve::_internal_set_tileorder(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tileorder_ = value;
}

// -------------------------------------------------------------------

// BuyArrowResolve

// bool isBought = 1;
inline void BuyArrowResolve::clear_isbought() {
  _impl_.isbought_ = false;
}
inline bool BuyArrowResolve::isbought() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.BuyArrowResolve.isBought)
  return _internal_isbought();
}
inline void BuyArrowResolve::set_isbought(bool value) {
  _internal_set_isbought(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.BuyArrowResolve.isBought)
}
inline bool BuyArrowResolve::_internal_isbought() const {
  return _impl_.isbought_;
}
inline void BuyArrowResolve::_internal_set_isbought(bool value) {
  ;
  _impl_.isbought_ = value;
}

// optional .MonopolyGameMessages.ArrowDirection newDirection = 2;
inline bool BuyArrowResolve::has_newdirection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BuyArrowResolve::clear_newdirection() {
  _impl_.newdirection_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::MonopolyGameMessages::ArrowDirection BuyArrowResolve::newdirection() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.BuyArrowResolve.newDirection)
  return _internal_newdirection();
}
inline void BuyArrowResolve::set_newdirection(::MonopolyGameMessages::ArrowDirection value) {
   _internal_set_newdirection(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.BuyArrowResolve.newDirection)
}
inline ::MonopolyGameMessages::ArrowDirection BuyArrowResolve::_internal_newdirection() const {
  return static_cast<::MonopolyGameMessages::ArrowDirection>(_impl_.newdirection_);
}
inline void BuyArrowResolve::_internal_set_newdirection(::MonopolyGameMessages::ArrowDirection value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.newdirection_ = value;
}

// -------------------------------------------------------------------

// DicesAreDrawn

// -------------------------------------------------------------------

// PieceMovingIsDrawn

// -------------------------------------------------------------------

// TimeForResolveOut

// -------------------------------------------------------------------

// TimeForWaitOut

// -------------------------------------------------------------------

// GameState

// .MonopolyGameMessages.State state = 1;
inline void GameState::clear_state() {
  _impl_.state_ = 0;
}
inline ::MonopolyGameMessages::State GameState::state() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.GameState.state)
  return _internal_state();
}
inline void GameState::set_state(::MonopolyGameMessages::State value) {
   _internal_set_state(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.GameState.state)
}
inline ::MonopolyGameMessages::State GameState::_internal_state() const {
  return static_cast<::MonopolyGameMessages::State>(_impl_.state_);
}
inline void GameState::_internal_set_state(::MonopolyGameMessages::State value) {
  ;
  _impl_.state_ = value;
}

// uint32 currentTurn = 2;
inline void GameState::clear_currentturn() {
  _impl_.currentturn_ = 0u;
}
inline ::uint32_t GameState::currentturn() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.GameState.currentTurn)
  return _internal_currentturn();
}
inline void GameState::set_currentturn(::uint32_t value) {
  _internal_set_currentturn(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.GameState.currentTurn)
}
inline ::uint32_t GameState::_internal_currentturn() const {
  return _impl_.currentturn_;
}
inline void GameState::_internal_set_currentturn(::uint32_t value) {
  ;
  _impl_.currentturn_ = value;
}

// uint32 currentStage = 3;
inline void GameState::clear_currentstage() {
  _impl_.currentstage_ = 0u;
}
inline ::uint32_t GameState::currentstage() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.GameState.currentStage)
  return _internal_currentstage();
}
inline void GameState::set_currentstage(::uint32_t value) {
  _internal_set_currentstage(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.GameState.currentStage)
}
inline ::uint32_t GameState::_internal_currentstage() const {
  return _impl_.currentstage_;
}
inline void GameState::_internal_set_currentstage(::uint32_t value) {
  ;
  _impl_.currentstage_ = value;
}

// optional .MonopolyGameMessages.PlayerNumber whoseTurn = 4;
inline bool GameState::has_whoseturn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GameState::clear_whoseturn() {
  _impl_.whoseturn_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::MonopolyGameMessages::PlayerNumber GameState::whoseturn() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.GameState.whoseTurn)
  return _internal_whoseturn();
}
inline void GameState::set_whoseturn(::MonopolyGameMessages::PlayerNumber value) {
   _internal_set_whoseturn(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.GameState.whoseTurn)
}
inline ::MonopolyGameMessages::PlayerNumber GameState::_internal_whoseturn() const {
  return static_cast<::MonopolyGameMessages::PlayerNumber>(_impl_.whoseturn_);
}
inline void GameState::_internal_set_whoseturn(::MonopolyGameMessages::PlayerNumber value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.whoseturn_ = value;
}

// repeated uint32 trace = 5;
inline int GameState::_internal_trace_size() const {
  return _impl_.trace_.size();
}
inline int GameState::trace_size() const {
  return _internal_trace_size();
}
inline void GameState::clear_trace() {
  _internal_mutable_trace()->Clear();
}
inline ::uint32_t GameState::trace(int index) const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.GameState.trace)
  return _internal_trace(index);
}
inline void GameState::set_trace(int index, ::uint32_t value) {
  _internal_mutable_trace()->Set(index, value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.GameState.trace)
}
inline void GameState::add_trace(::uint32_t value) {
  _internal_add_trace(value);
  // @@protoc_insertion_point(field_add:MonopolyGameMessages.GameState.trace)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& GameState::trace() const {
  // @@protoc_insertion_point(field_list:MonopolyGameMessages.GameState.trace)
  return _internal_trace();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* GameState::mutable_trace() {
  // @@protoc_insertion_point(field_mutable_list:MonopolyGameMessages.GameState.trace)
  return _internal_mutable_trace();
}

inline ::uint32_t GameState::_internal_trace(int index) const {
  return _internal_trace().Get(index);
}
inline void GameState::_internal_add_trace(::uint32_t value) {
  _internal_mutable_trace()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& GameState::_internal_trace() const {
  return _impl_.trace_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* GameState::_internal_mutable_trace() {
  return &_impl_.trace_;
}

// .MonopolyGameMessages.Dices dices = 6;
inline bool GameState::has_dices() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dices_ != nullptr);
  return value;
}
inline void GameState::clear_dices() {
  if (_impl_.dices_ != nullptr) _impl_.dices_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MonopolyGameMessages::Dices& GameState::_internal_dices() const {
  const ::MonopolyGameMessages::Dices* p = _impl_.dices_;
  return p != nullptr ? *p : reinterpret_cast<const ::MonopolyGameMessages::Dices&>(
      ::MonopolyGameMessages::_Dices_default_instance_);
}
inline const ::MonopolyGameMessages::Dices& GameState::dices() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.GameState.dices)
  return _internal_dices();
}
inline void GameState::unsafe_arena_set_allocated_dices(
    ::MonopolyGameMessages::Dices* dices) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dices_);
  }
  _impl_.dices_ = dices;
  if (dices) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MonopolyGameMessages.GameState.dices)
}
inline ::MonopolyGameMessages::Dices* GameState::release_dices() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MonopolyGameMessages::Dices* temp = _impl_.dices_;
  _impl_.dices_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MonopolyGameMessages::Dices* GameState::unsafe_arena_release_dices() {
  // @@protoc_insertion_point(field_release:MonopolyGameMessages.GameState.dices)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MonopolyGameMessages::Dices* temp = _impl_.dices_;
  _impl_.dices_ = nullptr;
  return temp;
}
inline ::MonopolyGameMessages::Dices* GameState::_internal_mutable_dices() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.dices_ == nullptr) {
    auto* p = CreateMaybeMessage<::MonopolyGameMessages::Dices>(GetArenaForAllocation());
    _impl_.dices_ = p;
  }
  return _impl_.dices_;
}
inline ::MonopolyGameMessages::Dices* GameState::mutable_dices() {
  ::MonopolyGameMessages::Dices* _msg = _internal_mutable_dices();
  // @@protoc_insertion_point(field_mutable:MonopolyGameMessages.GameState.dices)
  return _msg;
}
inline void GameState::set_allocated_dices(::MonopolyGameMessages::Dices* dices) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dices_;
  }
  if (dices) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dices);
    if (message_arena != submessage_arena) {
      dices = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dices, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dices_ = dices;
  // @@protoc_insertion_point(field_set_allocated:MonopolyGameMessages.GameState.dices)
}

// repeated .MonopolyGameMessages.Tile map = 7;
inline int GameState::_internal_map_size() const {
  return _impl_.map_.size();
}
inline int GameState::map_size() const {
  return _internal_map_size();
}
inline void GameState::clear_map() {
  _internal_mutable_map()->Clear();
}
inline ::MonopolyGameMessages::Tile* GameState::mutable_map(int index) {
  // @@protoc_insertion_point(field_mutable:MonopolyGameMessages.GameState.map)
  return _internal_mutable_map()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::Tile >*
GameState::mutable_map() {
  // @@protoc_insertion_point(field_mutable_list:MonopolyGameMessages.GameState.map)
  return _internal_mutable_map();
}
inline const ::MonopolyGameMessages::Tile& GameState::_internal_map(int index) const {
  return _internal_map().Get(index);
}
inline const ::MonopolyGameMessages::Tile& GameState::map(int index) const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.GameState.map)
  return _internal_map(index);
}
inline ::MonopolyGameMessages::Tile* GameState::_internal_add_map() {
  return _internal_mutable_map()->Add();
}
inline ::MonopolyGameMessages::Tile* GameState::add_map() {
  ::MonopolyGameMessages::Tile* _add = _internal_add_map();
  // @@protoc_insertion_point(field_add:MonopolyGameMessages.GameState.map)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::Tile >&
GameState::map() const {
  // @@protoc_insertion_point(field_list:MonopolyGameMessages.GameState.map)
  return _internal_map();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::Tile>&
GameState::_internal_map() const {
  return _impl_.map_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::Tile>*
GameState::_internal_mutable_map() {
  return &_impl_.map_;
}

// repeated .MonopolyGameMessages.Player players = 8;
inline int GameState::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int GameState::players_size() const {
  return _internal_players_size();
}
inline void GameState::clear_players() {
  _internal_mutable_players()->Clear();
}
inline ::MonopolyGameMessages::Player* GameState::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:MonopolyGameMessages.GameState.players)
  return _internal_mutable_players()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::Player >*
GameState::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:MonopolyGameMessages.GameState.players)
  return _internal_mutable_players();
}
inline const ::MonopolyGameMessages::Player& GameState::_internal_players(int index) const {
  return _internal_players().Get(index);
}
inline const ::MonopolyGameMessages::Player& GameState::players(int index) const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.GameState.players)
  return _internal_players(index);
}
inline ::MonopolyGameMessages::Player* GameState::_internal_add_players() {
  return _internal_mutable_players()->Add();
}
inline ::MonopolyGameMessages::Player* GameState::add_players() {
  ::MonopolyGameMessages::Player* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:MonopolyGameMessages.GameState.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MonopolyGameMessages::Player >&
GameState::players() const {
  // @@protoc_insertion_point(field_list:MonopolyGameMessages.GameState.players)
  return _internal_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::Player>&
GameState::_internal_players() const {
  return _impl_.players_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::MonopolyGameMessages::Player>*
GameState::_internal_mutable_players() {
  return &_impl_.players_;
}

// -------------------------------------------------------------------

// AwaitedResolve

// .MonopolyGameMessages.AwaitedMessage await = 1;
inline void AwaitedResolve::clear_await() {
  _impl_.await_ = 0;
}
inline ::MonopolyGameMessages::AwaitedMessage AwaitedResolve::await() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.AwaitedResolve.await)
  return _internal_await();
}
inline void AwaitedResolve::set_await(::MonopolyGameMessages::AwaitedMessage value) {
   _internal_set_await(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.AwaitedResolve.await)
}
inline ::MonopolyGameMessages::AwaitedMessage AwaitedResolve::_internal_await() const {
  return static_cast<::MonopolyGameMessages::AwaitedMessage>(_impl_.await_);
}
inline void AwaitedResolve::_internal_set_await(::MonopolyGameMessages::AwaitedMessage value) {
  ;
  _impl_.await_ = value;
}

// .MonopolyGameMessages.Tile target = 2;
inline bool AwaitedResolve::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline void AwaitedResolve::clear_target() {
  if (_impl_.target_ != nullptr) _impl_.target_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MonopolyGameMessages::Tile& AwaitedResolve::_internal_target() const {
  const ::MonopolyGameMessages::Tile* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::MonopolyGameMessages::Tile&>(
      ::MonopolyGameMessages::_Tile_default_instance_);
}
inline const ::MonopolyGameMessages::Tile& AwaitedResolve::target() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.AwaitedResolve.target)
  return _internal_target();
}
inline void AwaitedResolve::unsafe_arena_set_allocated_target(
    ::MonopolyGameMessages::Tile* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MonopolyGameMessages.AwaitedResolve.target)
}
inline ::MonopolyGameMessages::Tile* AwaitedResolve::release_target() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MonopolyGameMessages::Tile* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MonopolyGameMessages::Tile* AwaitedResolve::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:MonopolyGameMessages.AwaitedResolve.target)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MonopolyGameMessages::Tile* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::MonopolyGameMessages::Tile* AwaitedResolve::_internal_mutable_target() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::MonopolyGameMessages::Tile>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::MonopolyGameMessages::Tile* AwaitedResolve::mutable_target() {
  ::MonopolyGameMessages::Tile* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:MonopolyGameMessages.AwaitedResolve.target)
  return _msg;
}
inline void AwaitedResolve::set_allocated_target(::MonopolyGameMessages::Tile* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:MonopolyGameMessages.AwaitedResolve.target)
}

// -------------------------------------------------------------------

// TileStat

// .MonopolyGameMessages.TileType type = 1;
inline void TileStat::clear_type() {
  _impl_.type_ = 0;
}
inline ::MonopolyGameMessages::TileType TileStat::type() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.TileStat.type)
  return _internal_type();
}
inline void TileStat::set_type(::MonopolyGameMessages::TileType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.TileStat.type)
}
inline ::MonopolyGameMessages::TileType TileStat::_internal_type() const {
  return static_cast<::MonopolyGameMessages::TileType>(_impl_.type_);
}
inline void TileStat::_internal_set_type(::MonopolyGameMessages::TileType value) {
  ;
  _impl_.type_ = value;
}

// uint32 value = 2;
inline void TileStat::clear_value() {
  _impl_.value_ = 0u;
}
inline ::uint32_t TileStat::value() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.TileStat.value)
  return _internal_value();
}
inline void TileStat::set_value(::uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.TileStat.value)
}
inline ::uint32_t TileStat::_internal_value() const {
  return _impl_.value_;
}
inline void TileStat::_internal_set_value(::uint32_t value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Dices

// uint32 left = 1;
inline void Dices::clear_left() {
  _impl_.left_ = 0u;
}
inline ::uint32_t Dices::left() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Dices.left)
  return _internal_left();
}
inline void Dices::set_left(::uint32_t value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Dices.left)
}
inline ::uint32_t Dices::_internal_left() const {
  return _impl_.left_;
}
inline void Dices::_internal_set_left(::uint32_t value) {
  ;
  _impl_.left_ = value;
}

// uint32 right = 2;
inline void Dices::clear_right() {
  _impl_.right_ = 0u;
}
inline ::uint32_t Dices::right() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Dices.right)
  return _internal_right();
}
inline void Dices::set_right(::uint32_t value) {
  _internal_set_right(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Dices.right)
}
inline ::uint32_t Dices::_internal_right() const {
  return _impl_.right_;
}
inline void Dices::_internal_set_right(::uint32_t value) {
  ;
  _impl_.right_ = value;
}

// -------------------------------------------------------------------

// Tile

// uint32 order = 1;
inline void Tile::clear_order() {
  _impl_.order_ = 0u;
}
inline ::uint32_t Tile::order() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Tile.order)
  return _internal_order();
}
inline void Tile::set_order(::uint32_t value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Tile.order)
}
inline ::uint32_t Tile::_internal_order() const {
  return _impl_.order_;
}
inline void Tile::_internal_set_order(::uint32_t value) {
  ;
  _impl_.order_ = value;
}

// .MonopolyGameMessages.TileType type = 2;
inline void Tile::clear_type() {
  _impl_.type_ = 0;
}
inline ::MonopolyGameMessages::TileType Tile::type() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Tile.type)
  return _internal_type();
}
inline void Tile::set_type(::MonopolyGameMessages::TileType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Tile.type)
}
inline ::MonopolyGameMessages::TileType Tile::_internal_type() const {
  return static_cast<::MonopolyGameMessages::TileType>(_impl_.type_);
}
inline void Tile::_internal_set_type(::MonopolyGameMessages::TileType value) {
  ;
  _impl_.type_ = value;
}

// .MonopolyGameMessages.PlayerNumber owner = 3;
inline void Tile::clear_owner() {
  _impl_.owner_ = 0;
}
inline ::MonopolyGameMessages::PlayerNumber Tile::owner() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Tile.owner)
  return _internal_owner();
}
inline void Tile::set_owner(::MonopolyGameMessages::PlayerNumber value) {
   _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Tile.owner)
}
inline ::MonopolyGameMessages::PlayerNumber Tile::_internal_owner() const {
  return static_cast<::MonopolyGameMessages::PlayerNumber>(_impl_.owner_);
}
inline void Tile::_internal_set_owner(::MonopolyGameMessages::PlayerNumber value) {
  ;
  _impl_.owner_ = value;
}

// uint32 minDisplayStage = 4;
inline void Tile::clear_mindisplaystage() {
  _impl_.mindisplaystage_ = 0u;
}
inline ::uint32_t Tile::mindisplaystage() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Tile.minDisplayStage)
  return _internal_mindisplaystage();
}
inline void Tile::set_mindisplaystage(::uint32_t value) {
  _internal_set_mindisplaystage(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Tile.minDisplayStage)
}
inline ::uint32_t Tile::_internal_mindisplaystage() const {
  return _impl_.mindisplaystage_;
}
inline void Tile::_internal_set_mindisplaystage(::uint32_t value) {
  ;
  _impl_.mindisplaystage_ = value;
}

// uint32 minActivationStage = 5;
inline void Tile::clear_minactivationstage() {
  _impl_.minactivationstage_ = 0u;
}
inline ::uint32_t Tile::minactivationstage() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Tile.minActivationStage)
  return _internal_minactivationstage();
}
inline void Tile::set_minactivationstage(::uint32_t value) {
  _internal_set_minactivationstage(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Tile.minActivationStage)
}
inline ::uint32_t Tile::_internal_minactivationstage() const {
  return _impl_.minactivationstage_;
}
inline void Tile::_internal_set_minactivationstage(::uint32_t value) {
  ;
  _impl_.minactivationstage_ = value;
}

// repeated .MonopolyGameMessages.PlayerNumber piecesOnPosition = 6;
inline int Tile::_internal_piecesonposition_size() const {
  return _impl_.piecesonposition_.size();
}
inline int Tile::piecesonposition_size() const {
  return _internal_piecesonposition_size();
}
inline void Tile::clear_piecesonposition() {
  _internal_mutable_piecesonposition()->Clear();
}
inline ::MonopolyGameMessages::PlayerNumber Tile::piecesonposition(int index) const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Tile.piecesOnPosition)
  return _internal_piecesonposition(index);
}
inline void Tile::set_piecesonposition(int index, ::MonopolyGameMessages::PlayerNumber value) {
  _internal_mutable_piecesonposition()->Set(index, value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Tile.piecesOnPosition)
}
inline void Tile::add_piecesonposition(::MonopolyGameMessages::PlayerNumber value) {
  _internal_add_piecesonposition(value);
  // @@protoc_insertion_point(field_add:MonopolyGameMessages.Tile.piecesOnPosition)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& Tile::piecesonposition() const {
  // @@protoc_insertion_point(field_list:MonopolyGameMessages.Tile.piecesOnPosition)
  return _internal_piecesonposition();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Tile::mutable_piecesonposition() {
  // @@protoc_insertion_point(field_mutable_list:MonopolyGameMessages.Tile.piecesOnPosition)
  return _internal_mutable_piecesonposition();
}
inline ::MonopolyGameMessages::PlayerNumber Tile::_internal_piecesonposition(int index) const {
  return static_cast<::MonopolyGameMessages::PlayerNumber>(_internal_piecesonposition().Get(index));
}
inline void Tile::_internal_add_piecesonposition(::MonopolyGameMessages::PlayerNumber value) {
  _internal_mutable_piecesonposition()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& Tile::_internal_piecesonposition() const {
  return _impl_.piecesonposition_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Tile::_internal_mutable_piecesonposition() {
  return &_impl_.piecesonposition_;
}

// uint32 costForYou = 7;
inline void Tile::clear_costforyou() {
  _impl_.costforyou_ = 0u;
}
inline ::uint32_t Tile::costforyou() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Tile.costForYou)
  return _internal_costforyou();
}
inline void Tile::set_costforyou(::uint32_t value) {
  _internal_set_costforyou(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Tile.costForYou)
}
inline ::uint32_t Tile::_internal_costforyou() const {
  return _impl_.costforyou_;
}
inline void Tile::_internal_set_costforyou(::uint32_t value) {
  ;
  _impl_.costforyou_ = value;
}

// uint32 incomeForOwner = 8;
inline void Tile::clear_incomeforowner() {
  _impl_.incomeforowner_ = 0u;
}
inline ::uint32_t Tile::incomeforowner() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Tile.incomeForOwner)
  return _internal_incomeforowner();
}
inline void Tile::set_incomeforowner(::uint32_t value) {
  _internal_set_incomeforowner(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Tile.incomeForOwner)
}
inline ::uint32_t Tile::_internal_incomeforowner() const {
  return _impl_.incomeforowner_;
}
inline void Tile::_internal_set_incomeforowner(::uint32_t value) {
  ;
  _impl_.incomeforowner_ = value;
}

// optional .MonopolyGameMessages.ArrowDirection direction = 9;
inline bool Tile::has_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Tile::clear_direction() {
  _impl_.direction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::MonopolyGameMessages::ArrowDirection Tile::direction() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Tile.direction)
  return _internal_direction();
}
inline void Tile::set_direction(::MonopolyGameMessages::ArrowDirection value) {
   _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Tile.direction)
}
inline ::MonopolyGameMessages::ArrowDirection Tile::_internal_direction() const {
  return static_cast<::MonopolyGameMessages::ArrowDirection>(_impl_.direction_);
}
inline void Tile::_internal_set_direction(::MonopolyGameMessages::ArrowDirection value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.direction_ = value;
}

// repeated .MonopolyGameMessages.ArrowDirection allowDirections = 10;
inline int Tile::_internal_allowdirections_size() const {
  return _impl_.allowdirections_.size();
}
inline int Tile::allowdirections_size() const {
  return _internal_allowdirections_size();
}
inline void Tile::clear_allowdirections() {
  _internal_mutable_allowdirections()->Clear();
}
inline ::MonopolyGameMessages::ArrowDirection Tile::allowdirections(int index) const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Tile.allowDirections)
  return _internal_allowdirections(index);
}
inline void Tile::set_allowdirections(int index, ::MonopolyGameMessages::ArrowDirection value) {
  _internal_mutable_allowdirections()->Set(index, value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Tile.allowDirections)
}
inline void Tile::add_allowdirections(::MonopolyGameMessages::ArrowDirection value) {
  _internal_add_allowdirections(value);
  // @@protoc_insertion_point(field_add:MonopolyGameMessages.Tile.allowDirections)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& Tile::allowdirections() const {
  // @@protoc_insertion_point(field_list:MonopolyGameMessages.Tile.allowDirections)
  return _internal_allowdirections();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Tile::mutable_allowdirections() {
  // @@protoc_insertion_point(field_mutable_list:MonopolyGameMessages.Tile.allowDirections)
  return _internal_mutable_allowdirections();
}
inline ::MonopolyGameMessages::ArrowDirection Tile::_internal_allowdirections(int index) const {
  return static_cast<::MonopolyGameMessages::ArrowDirection>(_internal_allowdirections().Get(index));
}
inline void Tile::_internal_add_allowdirections(::MonopolyGameMessages::ArrowDirection value) {
  _internal_mutable_allowdirections()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& Tile::_internal_allowdirections() const {
  return _impl_.allowdirections_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Tile::_internal_mutable_allowdirections() {
  return &_impl_.allowdirections_;
}

// -------------------------------------------------------------------

// Player

// uint32 userID = 1;
inline void Player::clear_userid() {
  _impl_.userid_ = 0u;
}
inline ::uint32_t Player::userid() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Player.userID)
  return _internal_userid();
}
inline void Player::set_userid(::uint32_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Player.userID)
}
inline ::uint32_t Player::_internal_userid() const {
  return _impl_.userid_;
}
inline void Player::_internal_set_userid(::uint32_t value) {
  ;
  _impl_.userid_ = value;
}

// string nickname = 2;
inline void Player::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& Player::nickname() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Player.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Player::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Player.nickname)
}
inline std::string* Player::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:MonopolyGameMessages.Player.nickname)
  return _s;
}
inline const std::string& Player::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void Player::_internal_set_nickname(const std::string& value) {
  ;


  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_nickname() {
  ;
  return _impl_.nickname_.Mutable( GetArenaForAllocation());
}
inline std::string* Player::release_nickname() {
  // @@protoc_insertion_point(field_release:MonopolyGameMessages.Player.nickname)
  return _impl_.nickname_.Release();
}
inline void Player::set_allocated_nickname(std::string* value) {
  _impl_.nickname_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MonopolyGameMessages.Player.nickname)
}

// .MonopolyGameMessages.PlayerNumber order = 3;
inline void Player::clear_order() {
  _impl_.order_ = 0;
}
inline ::MonopolyGameMessages::PlayerNumber Player::order() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Player.order)
  return _internal_order();
}
inline void Player::set_order(::MonopolyGameMessages::PlayerNumber value) {
   _internal_set_order(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Player.order)
}
inline ::MonopolyGameMessages::PlayerNumber Player::_internal_order() const {
  return static_cast<::MonopolyGameMessages::PlayerNumber>(_impl_.order_);
}
inline void Player::_internal_set_order(::MonopolyGameMessages::PlayerNumber value) {
  ;
  _impl_.order_ = value;
}

// uint32 income = 4;
inline void Player::clear_income() {
  _impl_.income_ = 0u;
}
inline ::uint32_t Player::income() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Player.income)
  return _internal_income();
}
inline void Player::set_income(::uint32_t value) {
  _internal_set_income(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Player.income)
}
inline ::uint32_t Player::_internal_income() const {
  return _impl_.income_;
}
inline void Player::_internal_set_income(::uint32_t value) {
  ;
  _impl_.income_ = value;
}

// uint32 balance = 5;
inline void Player::clear_balance() {
  _impl_.balance_ = 0u;
}
inline ::uint32_t Player::balance() const {
  // @@protoc_insertion_point(field_get:MonopolyGameMessages.Player.balance)
  return _internal_balance();
}
inline void Player::set_balance(::uint32_t value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:MonopolyGameMessages.Player.balance)
}
inline ::uint32_t Player::_internal_balance() const {
  return _impl_.balance_;
}
inline void Player::_internal_set_balance(::uint32_t value) {
  ;
  _impl_.balance_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace MonopolyGameMessages


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::MonopolyGameMessages::AwaitedMessage> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::MonopolyGameMessages::AwaitedMessage>() {
  return ::MonopolyGameMessages::AwaitedMessage_descriptor();
}
template <>
struct is_proto_enum<::MonopolyGameMessages::TileType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::MonopolyGameMessages::TileType>() {
  return ::MonopolyGameMessages::TileType_descriptor();
}
template <>
struct is_proto_enum<::MonopolyGameMessages::ArrowDirection> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::MonopolyGameMessages::ArrowDirection>() {
  return ::MonopolyGameMessages::ArrowDirection_descriptor();
}
template <>
struct is_proto_enum<::MonopolyGameMessages::PlayerNumber> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::MonopolyGameMessages::PlayerNumber>() {
  return ::MonopolyGameMessages::PlayerNumber_descriptor();
}
template <>
struct is_proto_enum<::MonopolyGameMessages::State> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::MonopolyGameMessages::State>() {
  return ::MonopolyGameMessages::State_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_MonopolyGameMessages_2eproto_2epb_2eh
